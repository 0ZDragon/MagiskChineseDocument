import{_ as s,c as e,o as a,d as n}from"./app.f353d06f.js";const y=JSON.parse('{"title":"内部细节","description":"","frontmatter":{},"headers":[{"level":2,"title":"文档结构","slug":"文档结构","link":"#文档结构","children":[{"level":3,"title":"“Magisk tmpfs 目录”中的路径","slug":"magisk-tmpfs-目录-中的路径","link":"#magisk-tmpfs-目录-中的路径","children":[]},{"level":3,"title":"/data 中的路径","slug":"data-中的路径","link":"#data-中的路径","children":[]}]},{"level":2,"title":"Magisk引导过程","slug":"magisk引导过程","link":"#magisk引导过程","children":[{"level":3,"title":"预初始化","slug":"预初始化","link":"#预初始化","children":[]},{"level":3,"title":"post-fs-data","slug":"post-fs-data","link":"#post-fs-data","children":[]},{"level":3,"title":"late_start","slug":"late-start","link":"#late-start","children":[]}]},{"level":2,"title":"Resetprop","slug":"resetprop","link":"#resetprop","children":[]},{"level":2,"title":"SELinux Policies","slug":"selinux-policies","link":"#selinux-policies","children":[]}],"relativePath":"details.md"}'),o={name:"details.md"},t=n(`<h1 id="内部细节" tabindex="-1">内部细节 <a class="header-anchor" href="#内部细节" aria-hidden="true">#</a></h1><h2 id="文档结构" tabindex="-1">文档结构 <a class="header-anchor" href="#文档结构" aria-hidden="true">#</a></h2><h3 id="magisk-tmpfs-目录-中的路径" tabindex="-1">“Magisk tmpfs 目录”中的路径 <a class="header-anchor" href="#magisk-tmpfs-目录-中的路径" aria-hidden="true">#</a></h3><p>Magisk 将安装一个 <code>tmpfs</code> 目录来存储一些临时数据。对于带有 <code>/sbin</code> 文件夹的设备，将选择该文件夹，因为它还将充当将二进制文件注入 <code>PATH</code> 的覆盖层。从Android 11 开始，<code>/sbin</code> 文件夹可能不存在，因此 Magisk 将在 <code>/dev</code> 下随机创建一个文件夹，并将其用作基本文件夹。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;"># 为了获得Magisk正在使用的当前基本文件夹，使用命令 \`magisk--path\`。</span></span>
<span class="line"><span style="color:#A6ACCD;"># 二进制文件，如 magisk、magiskinit 和所有小程序的符号链接直接存储</span></span>
<span class="line"><span style="color:#A6ACCD;"># 在此路径中。这意味着当这是/sbin，这些二进制文件将直接在 PATH 中。</span></span>
<span class="line"><span style="color:#A6ACCD;">MAGISKBASE=$(magisk --path)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"># Magisk 内部材料</span></span>
<span class="line"><span style="color:#A6ACCD;">MAGISKTMP=$MAGISKBASE/.magisk</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"># Magisk 的 BusyBox 目录。在此文件夹中存储 busybox 二进制文件和指向</span></span>
<span class="line"><span style="color:#A6ACCD;"># 其所有小程序的符号链接。</span></span>
<span class="line"><span style="color:#A6ACCD;"># 不推荐使用此目录，请直接调用 /data/adb/magisk/busybox 并使用</span></span>
<span class="line"><span style="color:#A6ACCD;"># Busybox 的 ASH 独立模式。将来将删除此路径的创建。</span></span>
<span class="line"><span style="color:#A6ACCD;">$MAGISKTMP/busybox</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"># /data/adb/modules 将挂载到此处。</span></span>
<span class="line"><span style="color:#A6ACCD;"># 由于 nosuid 挂载标志，未使用原始文件夹。</span></span>
<span class="line"><span style="color:#A6ACCD;">$MAGISKTMP/modules</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"># 当前 Magisk 安装配置</span></span>
<span class="line"><span style="color:#A6ACCD;">$MAGISKTMP/config</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"># 分区映像</span></span>
<span class="line"><span style="color:#A6ACCD;"># 此路径中的每个目录都将装载其目录名的分区。</span></span>
<span class="line"><span style="color:#A6ACCD;"># 例如 system，system_ext，vendor，data ...</span></span>
<span class="line"><span style="color:#A6ACCD;">$MAGISKTMP/mirror</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"># Magisk在内部创建用于挂载映像的 Block 设备。</span></span>
<span class="line"><span style="color:#A6ACCD;">$MAGISKTMP/block</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"># 根目录修补程序文件</span></span>
<span class="line"><span style="color:#A6ACCD;"># 在 system-as-root 的系统上，/不可写。</span></span>
<span class="line"><span style="color:#A6ACCD;"># 所有预初始化补丁文件都存储在这里绑定挂载。</span></span>
<span class="line"><span style="color:#A6ACCD;">$MAGISKTMP/rootdir</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="data-中的路径" tabindex="-1"><code>/data</code> 中的路径 <a class="header-anchor" href="#data-中的路径" aria-hidden="true">#</a></h3><p>一些二进制文件和文件应存储在 <code>/data</code> 中的非易失性存储中。为了防止检测，所有东西都必须存储在“/data”中安全且不可检测的地方。选择文件夹 <code>/data/adb</code> 是因为具有以下优点：</p><ul><li>它是现代安卓系统上的一个现有文件夹，因此不能作为Magisk存在的标志。</li><li>文件夹的权限默认为 <code>700</code>，所有者为 <code>root</code>，因此非root进程无法以任何可能的方式进入、读取和写入文件夹。</li><li>文件夹 secontext 标记为 <code>u:object_r:adb_data_file:s0</code>，很少有进程有权与该secontext进行任何交互。</li><li>该文件夹位于 <em>设备加密存储区</em> 中，因此一旦数据正确装载到FBE（基于文件的加密）设备中，即可访问该文件夹。</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">SECURE_DIR=/data/adb</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"># 存储常规 post-fs-data 脚本的文件夹</span></span>
<span class="line"><span style="color:#A6ACCD;">$SECURE_DIR/post-fs-data.d</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">#存储常规 late_start 服务脚本的文件夹</span></span>
<span class="line"><span style="color:#A6ACCD;">$SECURE_DIR/service.d</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"># Magisk 模块</span></span>
<span class="line"><span style="color:#A6ACCD;">$SECURE_DIR/modules</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"># 等待升级的Magisk模块</span></span>
<span class="line"><span style="color:#A6ACCD;"># 模块文件在挂载时无法安全修改</span></span>
<span class="line"><span style="color:#A6ACCD;"># 通过 Magisk app 安装的模块将存储在此处并将在下次重新启动时</span></span>
<span class="line"><span style="color:#A6ACCD;"># 合并到 $SECURE_DIR/modules 中</span></span>
<span class="line"><span style="color:#A6ACCD;">$SECURE_DIR/modules_update</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"># 数据库存储设置和 Root 权限</span></span>
<span class="line"><span style="color:#A6ACCD;">MAGISKDB=$SECURE_DIR/magisk.db</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"># 所有与magisk相关的二进制文件，包括 busybox、脚本</span></span>
<span class="line"><span style="color:#A6ACCD;"># 和 magisk 二进制文件。用于支持模块安装、addon.d、 </span></span>
<span class="line"><span style="color:#A6ACCD;"># Magisk app 等。</span></span>
<span class="line"><span style="color:#A6ACCD;">DATABIN=$SECURE_DIR/magisk</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="magisk引导过程" tabindex="-1">Magisk引导过程 <a class="header-anchor" href="#magisk引导过程" aria-hidden="true">#</a></h2><h3 id="预初始化" tabindex="-1">预初始化 <a class="header-anchor" href="#预初始化" aria-hidden="true">#</a></h3><p><code>magiskinit</code> will replace <code>init</code> as the first program to run.</p><ul><li>Early mount required partitions. On legacy system-as-root devices, we switch root to system; on 2SI devices, we patch the original <code>init</code> to redirect the 2nd stage init file to magiskinit and execute it to mount partitions for us.</li><li>Inject magisk services into <code>init.rc</code></li><li>On devices using monolithic policy, load sepolicy from <code>/sepolicy</code>; otherwise we hijack nodes in selinuxfs with FIFO, set <code>LD_PRELOAD</code> to hook <code>security_load_policy</code> and assist hijacking on 2SI devices, and start a daemon to wait until init tries to load sepolicy.</li><li>Patch sepolicy rules. If we are using &quot;hijack&quot; method, load patched sepolicy into kernel, unblock init and exit daemon</li><li>Execute the original <code>init</code> to continue the boot process</li></ul><h3 id="post-fs-data" tabindex="-1">post-fs-data <a class="header-anchor" href="#post-fs-data" aria-hidden="true">#</a></h3><p>This triggers on <code>post-fs-data</code> when <code>/data</code> is decrypted and mounted. The daemon <code>magiskd</code> will be launched, post-fs-data scripts are executed, and module files are magic mounted.</p><h3 id="late-start" tabindex="-1">late_start <a class="header-anchor" href="#late-start" aria-hidden="true">#</a></h3><p>Later in the booting process, the class <code>late_start</code> will be triggered, and Magisk &quot;service&quot; mode will be started. In this mode, service scripts are executed.</p><h2 id="resetprop" tabindex="-1">Resetprop <a class="header-anchor" href="#resetprop" aria-hidden="true">#</a></h2><p>Usually, system properties are designed to only be updated by <code>init</code> and read-only to non-root processes. With root you can change properties by sending requests to <code>property_service</code> (hosted by <code>init</code>) using commands such as <code>setprop</code>, but changing read-only props (props that start with <code>ro.</code> like <code>ro.build.product</code>) and deleting properties are still prohibited.</p><p><code>resetprop</code> is implemented by distilling out the source code related to system properties from AOSP and patched to allow direct modification to property area, or <code>prop_area</code>, bypassing the need to go through <code>property_service</code>. Since we are bypassing <code>property_service</code>, there are a few caveats:</p><ul><li><code>on property:foo=bar</code> actions registered in <code>*.rc</code> scripts will not be triggered if property changes does not go through <code>property_service</code>. The default set property behavior of <code>resetprop</code> matches <code>setprop</code>, which <strong>WILL</strong> trigger events (implemented by first deleting the property then set it via <code>property_service</code>). There is a flag <code>-n</code> to disable it if you need this special behavior.</li><li>persist properties (props that starts with <code>persist.</code>, like <code>persist.sys.usb.config</code>) are stored in both <code>prop_area</code> and <code>/data/property</code>. By default, deleting props will <strong>NOT</strong> remove it from persistent storage, meaning the property will be restored after the next reboot; reading props will <strong>NOT</strong> read from persistent storage, as this is the behavior of <code>getprop</code>. With the flag <code>-p</code>, deleting props will remove the prop in <strong>BOTH</strong> <code>prop_area</code> and <code>/data/property</code>, and reading props will be read from <strong>BOTH</strong> <code>prop_area</code> and persistent storage.</li></ul><h2 id="selinux-policies" tabindex="-1">SELinux Policies <a class="header-anchor" href="#selinux-policies" aria-hidden="true">#</a></h2><p>Magisk will patch the stock <code>sepolicy</code> to make sure root and Magisk operations can be done in a safe and secure way. The new domain <code>magisk</code> is effectively permissive, which is what <code>magiskd</code> and all root shell will run in. <code>magisk_file</code> is a new file type that is setup to be allowed to be accessed by every domain (unrestricted file context).</p><p>Before Android 8.0, all allowed su client domains are allowed to directly connect to <code>magiskd</code> and establish connection with the daemon to get a remote root shell. Magisk also have to relax some <code>ioctl</code> operations so root shells can function properly.</p><p>After Android 8.0, to reduce relaxation of rules in Android&#39;s sandbox, a new SELinux model is deployed. The <code>magisk</code> binary is labelled with <code>magisk_exec</code> file type, and processes running as allowed su client domains executing the <code>magisk</code> binary (this includes the <code>su</code> command) will transit to <code>magisk_client</code> by using a <code>type_transition</code> rule. Rules strictly restrict that only <code>magisk</code> domain processes are allowed to attribute files to <code>magisk_exec</code>. Direct connection to sockets of <code>magiskd</code> are not allowed; the only way to access the daemon is through a <code>magisk_client</code> process. These changes allow us to keep the sandbox intact, and keep Magisk specific rules separated from the rest of the policies.</p><p>The full set of rules can be found in <code>magiskpolicy/rules.cpp</code>.</p>`,26),l=[t];function i(p,c,r,d,h,A){return a(),e("div",null,l)}const C=s(o,[["render",i]]);export{y as __pageData,C as default};
