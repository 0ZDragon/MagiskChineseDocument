import{_ as e,c as t,o,a as r}from"./app.e80040ee.js";const m=JSON.parse('{"title":"Android 引导诡计","description":"","frontmatter":{},"headers":[{"level":2,"title":"术语","slug":"术语","link":"#术语","children":[]},{"level":2,"title":"引导方法","slug":"引导方法","link":"#引导方法","children":[{"level":3,"title":"讨论","slug":"讨论","link":"#讨论","children":[]}]},{"level":2,"title":"一些历史","slug":"一些历史","link":"#一些历史","children":[]},{"level":2,"title":"Piecing Things Together","slug":"piecing-things-together","link":"#piecing-things-together","children":[]},{"level":2,"title":"参考链接","slug":"参考链接","link":"#参考链接","children":[]}],"relativePath":"boot.md","lastUpdated":1673281957000}'),i={name:"boot.md"},d=r('<h1 id="android-引导诡计" tabindex="-1">Android 引导诡计 <a class="header-anchor" href="#android-引导诡计" aria-hidden="true">#</a></h1><h2 id="术语" tabindex="-1">术语 <a class="header-anchor" href="#术语" aria-hidden="true">#</a></h2><ul><li><strong>rootdir</strong>：根目录 (<code>/</code>)。所有 文件、文件夹或文件系统 都存储在 rootdir 中或挂载在 rootdir 下。在 Android 上，文件系统可以是 <code>rootfs</code> 或 <code>system</code> 分区。</li><li><strong><code>initramfs</code></strong>：Android 启动映像中的一个部分，Linux 内核将使用它作为<code>rootfs</code>。人们也可以使用术语 <strong>ramdisk</strong></li><li><strong><code>recovery</code> 和 <code>boot</code> 分区</strong>：这两个实际上非常相似：都是包含 ramdisk 和 Linux 内核的 Android 启动映像（加上其他一些东西）。 唯一的区别是，启动 <code>boot</code> 分区将把我们带到 Android，而 <code>recovery</code> 有一个用于修复和升级设备的极简自带 Linux 环境。</li><li><strong>SAR</strong>：系统作为根（System-as-root）。也就是说，设备使用 <code>system</code> 作为rootdir，而不是 <code>rootfs</code></li><li><strong>A/B, A-only</strong>：对于支持<a href="https://source.android.google.cn/docs/core/ota/ab" target="_blank" rel="noreferrer">无缝系统更新</a>的设备，它将具有所有只读分区的2个插槽（partition）；我们称这些为<strong>A/B设备</strong>。为了区分，非A/B设备将称为<strong>A-only</strong></li><li><strong>2SI</strong>：两阶段初始化。Android 10+ 的启动方式。稍后提供更多信息。</li></ul><p>以下是一些参数，可帮助您更精确地定义设备的 Android 版本：</p><ul><li><strong>LV</strong>：推出版本。设备<strong>推出</strong>时使用的安卓版本。也就是说，设备首次上市时预装的 Android 版本。</li><li><strong>RV</strong>：运行版本。设备当前运行的 Android 版本。</li></ul><p>我们将使用 <strong>Android API 级别</strong> 来表示 LV 和 RV 。API 级别和 Android 版本之间的映射可以在(<a href="https://source.android.com/setup/start/build-numbers#platform-code-names-versions-api-levels-and-ndk-releases" target="_blank" rel="noreferrer">https://source.android.com/setup/start/build-numbers#platform-code-names-versions-api-levels-and-ndk-releases</a>)中看到。例如：Pixel XL 随 Android 7.1 发布，并运行 Android 10，这些参数将为 <code>(LV = 25, RV = 29)</code> 。</p><h2 id="引导方法" tabindex="-1">引导方法 <a class="header-anchor" href="#引导方法" aria-hidden="true">#</a></h2><p>Android 启动可以大致分为 3 种主要的不同方法。我们提供了一个一般的经验法则，以确定您的设备最有可能使用哪种方法，但例外情况单独列出。</p><table><thead><tr><th style="text-align:center;">方法</th><th>初始根目录</th><th>最终根目录</th></tr></thead><tbody><tr><td style="text-align:center;"><strong>A</strong></td><td><code>rootfs</code></td><td><code>rootfs</code></td></tr><tr><td style="text-align:center;"><strong>B</strong></td><td><code>system</code></td><td><code>system</code></td></tr><tr><td style="text-align:center;"><strong>C</strong></td><td><code>rootfs</code></td><td><code>system</code></td></tr></tbody></table><ul><li><strong>Method A - Legacy ramdisk</strong>: This is how <em>all</em> Android devices used to boot (good old days). The kernel uses <code>initramfs</code> as rootdir, and exec <code>/init</code> to boot. <ul><li>Devices that does not fall in any of Method B and C&#39;s criteria</li></ul></li><li><strong>Method B - Legacy SAR</strong>: This method was first seen on Pixel 1. The kernel directly mounts the <code>system</code> partition as rootdir and exec <code>/init</code> to boot. <ul><li>Devices with <code>(LV = 28)</code></li><li>Google: Pixel 1 and 2. Pixel 3 and 3a when <code>(RV = 28)</code>.</li><li>OnePlus: 6 - 7</li><li>Maybe some <code>(LV &lt; 29)</code> Android Go devices?</li></ul></li><li><strong>Method C - 2SI ramdisk SAR</strong>: This method was first seen on Pixel 3 Android 10 developer preview. The kernel uses <code>initramfs</code> as rootdir and exec <code>/init</code> in <code>rootfs</code>. This <code>init</code> is responsible to mount the <code>system</code> partition and use it as the new rootdir, then finally exec <code>/system/bin/init</code> to boot. <ul><li>Devices with <code>(LV &gt;= 29)</code></li><li>Devices with <code>(LV &lt; 28, RV &gt;= 29)</code>, excluding those that were already using Method B</li><li>Google: Pixel 3 and 3a with <code>(RV &gt;= 29)</code></li></ul></li></ul><h3 id="讨论" tabindex="-1">讨论 <a class="header-anchor" href="#讨论" aria-hidden="true">#</a></h3><p>从文档来看，谷歌对 SAR 的定义只考虑了内核如何引导设备（上表中的<strong>初始根目录</strong>），这意味着从谷歌的角度来看，只有使用<strong>方法B</strong>的设备才被正式视为 SAR 设备。</p><p>然而，对于 Magisk 来说，真正的区别在于设备在完全启动时使用的是什么（上表中的<strong>最终根目录</strong>），这意味着<strong>就Magisk而言，方法 B 和方法 C 都是 SAR 的一种形式</strong>，但实施方式不同。除非另有特别说明，否则本文件后面提到的每一个 SAR 实例都将参考 <strong>Magisk 的定义</strong>。</p><p>通俗地说，方法 C 的标准有点复杂：您的设备足够现代，可以使用 Android 10+ 启动，或者您在使用方法 A 的设备上运行 Android 10+ 第三方 ROM。</p><ul><li>任何运行 Android 10+ 的设备都将自动使用方法 C</li><li><strong>方法 B 设备卡在方法 B 上</strong>，唯一的例外是 Pixel 3 和 3a，Google 对设备进行了改造以适应新方法。</li></ul><p>SAR 是 <a href="https://source.android.google.cn/devices/architecture#hidl" target="_blank" rel="noreferrer">Project Treble</a> 中非常重要的一部分，因为 rootdir 应该与平台绑定。这也是方法 B 和 C 带有 <code>(LV &gt;= ver)</code> 标准的原因，因为 Google 每年都强制所有 OEM 遵守更新的要求。</p><h2 id="一些历史" tabindex="-1">一些历史 <a class="header-anchor" href="#一些历史" aria-hidden="true">#</a></h2><p>When Google released the first generation Pixel, it also introduced <a href="https://source.android.com/devices/tech/ota/ab" target="_blank" rel="noreferrer">A/B (Seamless) System Updates</a>. Due to <a href="https://source.android.com/devices/tech/ota/ab/ab_faqs" target="_blank" rel="noreferrer">storage size concerns</a>, there are several differences compared to A-only, the most relevant one being the removal of <code>recovery</code> partition and the recovery ramdisk being merged into <code>boot</code>.</p><p>Let&#39;s go back in time when Google is first designing A/B. If using SAR (only Boot Method B exists at that time), the kernel doesn&#39;t need <code>initramfs</code> to boot Android (because rootdir is in <code>system</code>). This mean we can be smart and just stuff the recovery ramdisk (containing the minimalist Linux environment) into <code>boot</code>, remove <code>recovery</code>, and let the kernel pick whichever rootdir to use (ramdisk or <code>system</code>) based on information from the bootloader.</p><p>As time passed from Android 7.1 to Android 10, Google introduced <a href="https://source.android.com/devices/tech/ota/dynamic_partitions/implement" target="_blank" rel="noreferrer">Dynamic Partitions</a>. This is bad news for SAR, because the Linux kernel cannot directly understand this new partition format, thus unable to directly mount <code>system</code> as rootdir. This is when they came up with Boot Method C: always boot into <code>initramfs</code>, and let userspace handle the rest of booting. This includes deciding whether to boot into Android or recovery, or as they officially call: <code>USES_RECOVERY_AS_BOOT</code>.</p><p>Some modern devices using A/B with 2SI also comes with <code>recovery_a/_b</code> partitions. This is officially supported with Google&#39;s standard. These devices will then only use the boot ramdisk to boot into Android as recovery is stored on a separate partition.</p><h2 id="piecing-things-together" tabindex="-1">Piecing Things Together <a class="header-anchor" href="#piecing-things-together" aria-hidden="true">#</a></h2><p>With all the knowledge above, now we can categorize all Android devices into these different types:</p><table><thead><tr><th style="text-align:center;">Type</th><th style="text-align:center;">Boot Method</th><th style="text-align:center;">Partition</th><th style="text-align:center;">2SI</th><th style="text-align:center;">Ramdisk in <code>boot</code></th></tr></thead><tbody><tr><td style="text-align:center;"><strong>I</strong></td><td style="text-align:center;">A</td><td style="text-align:center;">A-only</td><td style="text-align:center;">No</td><td style="text-align:center;"><code>boot</code> ramdisk</td></tr><tr><td style="text-align:center;"><strong>II</strong></td><td style="text-align:center;">B</td><td style="text-align:center;">A/B</td><td style="text-align:center;">Any</td><td style="text-align:center;"><code>recovery</code> ramdisk</td></tr><tr><td style="text-align:center;"><strong>III</strong></td><td style="text-align:center;">B</td><td style="text-align:center;">A-only</td><td style="text-align:center;">Any</td><td style="text-align:center;"><em><strong>N/A</strong></em></td></tr><tr><td style="text-align:center;"><strong>IV</strong></td><td style="text-align:center;">C</td><td style="text-align:center;">Any</td><td style="text-align:center;">Yes</td><td style="text-align:center;">Hybrid ramdisk</td></tr></tbody></table><p>These types are ordered chronologically by the time they were first available.</p><ul><li><strong>Type I</strong>: Good old legacy ramdisk boot</li><li><strong>Type II</strong>: Legacy A/B devices. Pixel 1 is the first device of this type, being both the first A/B and SAR device</li><li><strong>Type III</strong>: Late 2018 - 2019 devices that are A-only. <strong>The worst type of device to ever exist as far as Magisk is concerned.</strong></li><li><strong>Type IV</strong>: All devices using Boot Method C are Type IV. A/B Type IV ramdisk can boot into either Android or recovery based on info from bootloader; A-only Type IV ramdisk can only boot into Android.</li></ul><p>Further details on Type III devices: Magisk is always installed in the ramdisk of a boot image. For all other device types, because their <code>boot</code> partition have ramdisk included, Magisk can be easily installed by patching boot image through the Magisk app or flash zip in custom recovery. However for Type III devices, they are <strong>limited to install Magisk into the <code>recovery</code> partition</strong>. Magisk will not function when booted normally; instead Type III device owners have to always reboot to recovery to maintain Magisk access.</p><p>Some Type III devices&#39; bootloader will still accept and provide <code>initramfs</code> that was manually added to the <code>boot</code> image to the kernel (e.g. some Xiaomi phones), but many device don&#39;t (e.g. Samsung S10, Note 10). It solely depends on how the OEM implements its bootloader.</p><h2 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-hidden="true">#</a></h2><ul><li><a href="https://topjohnwu.github.io/Magisk/boot.html" target="_blank" rel="noreferrer">Magisk Android Booting Shenanigans</a></li></ul>',30),n=[d];function s(a,l,c,h,g,y){return o(),t("div",null,n)}const u=e(i,[["render",s]]);export{m as __pageData,u as default};
